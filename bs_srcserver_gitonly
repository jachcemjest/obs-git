#!/usr/bin/perl -w

package bs_srcserver_gitonly;

use strict;

my $GIT_HASH_LENGTH = 40

# lists all files from given package and revision identified by git commit hash
# TODO there are still some cases that will generate MD5s, not hashes...

sub lsrep {
  my ($projid, $packid, $srchash) = @_;
  die("no such revision\n") unless defined $srchash;
  local *F;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;

  # TODO: check what exactly means these special cases, i've just changed the variable name...
  if ($srchash eq 'upload') {
    open(F, '<', "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS") || die("$packid/$srchash-$packid: not in repository\n");
  } elsif ($srcmd5 eq 'pattern') {
    open(F, '<', "$projectsdir/$projid.pkg/pattern-MD5SUMS") || return {};
    # TODO: this is awful... and what to do with empty md5 in git version?
  } elsif ($srchash eq 'empty' || $srchash eq 'd41d8cd98f00b204e9800998ecf8427e') { 
    return {};
  } else {
    # this reads the file information from git
    if ($srchash !~ /^[0-9a-f]{$GIT_HASH_LENGTH}$/) {
      die("bad srcmd5 '$srchash'\n");
    }

    $repopath = "$srcrep/$projid/$packid/"
    my @gitfiles = `git ls-tree $srchash | cut -d' ' -f 3`;
    if ($? != 0 ) {
      die("$packid/$srchash-$packid: not in repository\n");
    }

    chomp @gitfiles;

    return {map {substr($_, $GIT_HASH_LENGTH + 1) => substr($_, 0, $GIT_HASH_LENGTH)} @gitfiles};
  }
  my @files = <F>;
  close F;
  chomp @files;
  return {map {substr($_, 34) => substr($_, 0, 32)} @files};
}


# creates *-MD5SUMS files. In git backend only for special cases not in source repository
# for these cases returns srcmd5, for normal sources an empty string, since hashes are needed
# at commit only
sub addmeta {
  my ($projid, $packid, $files, $rev) = @_;

  # calculate new meta sum
  my $meta = '';
  $meta .= "$files->{$_}  $_\n" for sort keys %$files;
  my $srcmd5 = Digest::MD5::md5_hex($meta);
  if ($rev && $rev eq 'upload') {
    mkdir_p("$srcrep/:upload");
    mkdir_p("$projectsdir/$projid.pkg");
    writestr("$srcrep/:upload/$$", "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS", $meta);
  } elsif ($rev && $rev eq 'pattern') {
    if ($meta ne '') {
      mkdir_p("$srcrep/:upload");
      mkdir_p("$projectsdir/$projid.pkg");
      writestr("$srcrep/:upload/$$", "$projectsdir/$projid.pkg/pattern-MD5SUMS", $meta);
    } else {
      unlink("$projectsdir/$projid.pkg/pattern-MD5SUMS");
    }
  } else {
    # normal packages don't need this function
    return "";
  }

  return $srcmd5;
}


sub putinsrcrep {
  my ($projid, $packid, $tmpfile, $filename) = @_;

  open(F, '<', $tmpfile) || die("$tmpfile: $!\n");

  $githash = `git --git-dir="$srcrep/$projid/$packid/" hash-object -w $tmpfile`;

  unlink($tmpfile);

  return $githash;
}

# TODO: just 'pseudocode'
sub urobcommit {
  my ($cgi, $projid, $packid) = @_; # zoznam suborov (subor,hash) je v $filelist (z PUTu)
  foreach ($file in $filelist) {
    # prida subor do commitu
    `GIT_DIR=srcgitrep/$projid/$packid git update-index --cacheinfo 0644 " + $file.git_hash + " " + $file.name`;
  }
  `GIT_DIR=srcgitrep/$projid/$packid git commit`;
  $hash = `GIT_DIR=srcgitrep/$projid/$packid git log | head -n 1 | cut -f 2 -d ' '`
  return $hash;
}

# TODO: this needs 2 more functions to implement and maybe more?
sub addrev {
  my ($projid, $packid, $files, $user, $comment, $target) = @_;
  die("project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  if ($packid eq '_pattern') {
    my $srcmd5 = addmeta($projid, $packid, $files, 'pattern');
    bs_srcserver_common::notify_repservers('project', $projid);

    return {'rev' => 'pattern', 'srcmd5' => $srcmd5};
  }
  die("package '$packid' is read-only\n") if $packid =~ /^_product:/;
  die("package '$packid' does not exist\n") unless -e "$projectsdir/$projid.pkg/$packid.xml";
  if ($target && $target eq 'upload') {
    my $srcmd5 = addmeta($projid, $packid, $files, 'upload');
    my $filename = (keys %$files)[0];
    BSHermes::notify("SRCSRV_UPLOAD", {project => $projid, package => $packid, filename => $filename, user => $user});
    return {'rev' => 'upload', 'srcmd5' => $srcmd5};
  } elsif ($target && $target eq 'repository') {
    # repository only upload.
    return {'rev' => 'repository'};
  } elsif (defined($target)) {
    # internal version only upload.
    # TODO: obs-git: this might be a problem - addmeta probably returns '' here...
    my $srcmd5 = addmeta($projid, $packid, $files);
    return {'rev' => $srcmd5, 'srcmd5' => $srcmd5};
  }
  die("bad projid\n") if $projid =~ /\// || $projid =~ /^\./;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  die("bad files\n") if grep {/\//} keys %$files;
  die("bad files\n") if grep {!/^[0-9a-f]{32}$/} values %$files;

  # TODO: obs-git: handle this correctly
  if ($packid eq '_product') {
    expandproduct($projid, $packid, $files, $user) || die("product conversation failed\n");
  }

  # get version/release from rpm spec/deb dsc/kiwi xml file
  my $version = 'unknown';
  my $release;
  my $bconf = Build::read_config('noarch');
  for my $type ('spec', 'dsc', 'kiwi') {
    my $file = bs_srcserver_common_notsure::findfile($projid, $packid, undef, $type, $files);
    next unless defined $file;
     # TODO: code the function - saves the file from project and package with specified hash into some temporary location
    my $tmpgitfile = fetchgitfile($srcrep, $packid, $files->{$file});
    my $d = Build::parse($bconf, $tmpgitfile );
    unlink($tmpgitfile);
    next unless defined $d->{'version'};
    $version = $d->{'version'};
    $release = $d->{'release'} if defined $d->{'release'};
    last;
  }
  if (defined($release)) {
    if ($release =~ /(\d+)\.<B_CNT>/) {
      $release = $1;
    } elsif ($release =~ /<RELEASE(\d+)>/) {
      $release = $1;
    } elsif ($release =~ /^(\d+)/) {
      $release = $1;
    } else {
      $release = '0';
    }
  }
  $release ||= '0';
  #my $srcmd5 = addmeta($projid, $packid, $files);
  # TODO: code this function - maybe can be impemented inside addmeta, but better solution would be outside
  my $githash = commitfiles($projid, $packid, $files);
  my $rev = {'srcmd5' => $githash, 'time' => time(), 'user' => $user, 'comment' => $comment, 'version' => $version, 'vrev' => $release};

  # TODO: these 'srcmd5' strings are names in files - they could be renamed, but it would have to be in whole system
  my $rev_old = BSFileDB::fdb_getlast("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay);
  $rev_old ||= {'srcmd5' => 'empty'};
  my $files_old = lsrep($projid, $packid, $rev_old->{'srcmd5'});
  my $filestr = BSHermes::generate_commit_flist($files_old, $files);

  $rev = BSFileDB::fdb_add_i2("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $rev, 'vrev', 'version', $version);
  BSHermes::notify("SRCSRV_COMMIT", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'}, user => $user, comment => $comment});

  # kill upload revision as we did a real commit
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");

  bs_srcserver_common::notify_repservers('package', $projid, $packid);
  return $rev;
}